// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// TxMock implements pgx.Tx
type TxMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func(ctx context.Context) (t1 mm_pgx.Tx, err error)
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mTxMockBegin

	funcCommit          func(ctx context.Context) (err error)
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTxMockCommit

	funcConn          func() (cp1 *mm_pgx.Conn)
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mTxMockConn

	funcCopyFrom          func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)
	inspectFuncCopyFrom   func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mTxMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...any)
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mTxMockExec

	funcLargeObjects          func() (l1 mm_pgx.LargeObjects)
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mTxMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mTxMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, sql string, args ...any)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mTxMockQuery

	funcQueryRow          func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...any)
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mTxMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTxMockRollback

	funcSendBatch          func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)
	inspectFuncSendBatch   func(ctx context.Context, b *mm_pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mTxMockSendBatch
}

// NewTxMock returns a mock for pgx.Tx
func NewTxMock(t minimock.Tester) *TxMock {
	m := &TxMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mTxMockBegin{mock: m}
	m.BeginMock.callArgs = []*TxMockBeginParams{}

	m.CommitMock = mTxMockCommit{mock: m}
	m.CommitMock.callArgs = []*TxMockCommitParams{}

	m.ConnMock = mTxMockConn{mock: m}

	m.CopyFromMock = mTxMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*TxMockCopyFromParams{}

	m.ExecMock = mTxMockExec{mock: m}
	m.ExecMock.callArgs = []*TxMockExecParams{}

	m.LargeObjectsMock = mTxMockLargeObjects{mock: m}

	m.PrepareMock = mTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*TxMockPrepareParams{}

	m.QueryMock = mTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*TxMockQueryParams{}

	m.QueryRowMock = mTxMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*TxMockQueryRowParams{}

	m.RollbackMock = mTxMockRollback{mock: m}
	m.RollbackMock.callArgs = []*TxMockRollbackParams{}

	m.SendBatchMock = mTxMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*TxMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTxMockBegin struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockBeginExpectation
	expectations       []*TxMockBeginExpectation

	callArgs []*TxMockBeginParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockBeginExpectation specifies expectation struct of the Tx.Begin
type TxMockBeginExpectation struct {
	mock      *TxMock
	params    *TxMockBeginParams
	paramPtrs *TxMockBeginParamPtrs
	results   *TxMockBeginResults
	Counter   uint64
}

// TxMockBeginParams contains parameters of the Tx.Begin
type TxMockBeginParams struct {
	ctx context.Context
}

// TxMockBeginParamPtrs contains pointers to parameters of the Tx.Begin
type TxMockBeginParamPtrs struct {
	ctx *context.Context
}

// TxMockBeginResults contains results of the Tx.Begin
type TxMockBeginResults struct {
	t1  mm_pgx.Tx
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mTxMockBegin) Optional() *mTxMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for Tx.Begin
func (mmBegin *mTxMockBegin) Expect(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.paramPtrs != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by ExpectParams functions")
	}

	mmBegin.defaultExpectation.params = &TxMockBeginParams{ctx}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Begin
func (mmBegin *mTxMockBegin) ExpectCtxParam1(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.params != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Expect")
	}

	if mmBegin.defaultExpectation.paramPtrs == nil {
		mmBegin.defaultExpectation.paramPtrs = &TxMockBeginParamPtrs{}
	}
	mmBegin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Tx.Begin
func (mmBegin *mTxMockBegin) Inspect(f func(ctx context.Context)) *mTxMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for TxMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Tx.Begin
func (mmBegin *mTxMockBegin) Return(t1 mm_pgx.Tx, err error) *TxMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &TxMockBeginResults{t1, err}
	return mmBegin.mock
}

// Set uses given function f to mock the Tx.Begin method
func (mmBegin *mTxMockBegin) Set(f func(ctx context.Context) (t1 mm_pgx.Tx, err error)) *TxMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Tx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Tx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the Tx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mTxMockBegin) When(ctx context.Context) *TxMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	expectation := &TxMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &TxMockBeginParams{ctx},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Tx.Begin return parameters for the expectation previously defined by the When method
func (e *TxMockBeginExpectation) Then(t1 mm_pgx.Tx, err error) *TxMock {
	e.results = &TxMockBeginResults{t1, err}
	return e.mock
}

// Times sets number of times Tx.Begin should be invoked
func (mmBegin *mTxMockBegin) Times(n uint64) *mTxMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of TxMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	return mmBegin
}

func (mmBegin *mTxMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements pgx.Tx
func (mmBegin *TxMock) Begin(ctx context.Context) (t1 mm_pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := TxMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, &mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_want_ptrs := mmBegin.BeginMock.defaultExpectation.paramPtrs

		mm_got := TxMockBeginParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBegin.t.Errorf("TxMock.Begin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("TxMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the TxMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to TxMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished TxMock.Begin invocations
func (mmBegin *TxMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of TxMock.Begin invocations
func (mmBegin *TxMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mTxMockBegin) Calls() []*TxMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*TxMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *TxMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Begin with params: %#v", *e.params)
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Begin")
		} else {
			m.t.Errorf("Expected call to TxMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Error("Expected call to TxMock.Begin")
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Begin but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), afterBeginCounter)
	}
}

type mTxMockCommit struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockCommitExpectation
	expectations       []*TxMockCommitExpectation

	callArgs []*TxMockCommitParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockCommitExpectation specifies expectation struct of the Tx.Commit
type TxMockCommitExpectation struct {
	mock      *TxMock
	params    *TxMockCommitParams
	paramPtrs *TxMockCommitParamPtrs
	results   *TxMockCommitResults
	Counter   uint64
}

// TxMockCommitParams contains parameters of the Tx.Commit
type TxMockCommitParams struct {
	ctx context.Context
}

// TxMockCommitParamPtrs contains pointers to parameters of the Tx.Commit
type TxMockCommitParamPtrs struct {
	ctx *context.Context
}

// TxMockCommitResults contains results of the Tx.Commit
type TxMockCommitResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mTxMockCommit) Optional() *mTxMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for Tx.Commit
func (mmCommit *mTxMockCommit) Expect(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.paramPtrs != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by ExpectParams functions")
	}

	mmCommit.defaultExpectation.params = &TxMockCommitParams{ctx}
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Commit
func (mmCommit *mTxMockCommit) ExpectCtxParam1(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.params != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Expect")
	}

	if mmCommit.defaultExpectation.paramPtrs == nil {
		mmCommit.defaultExpectation.paramPtrs = &TxMockCommitParamPtrs{}
	}
	mmCommit.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Tx.Commit
func (mmCommit *mTxMockCommit) Inspect(f func(ctx context.Context)) *mTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Tx.Commit
func (mmCommit *mTxMockCommit) Return(err error) *TxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TxMockCommitResults{err}
	return mmCommit.mock
}

// Set uses given function f to mock the Tx.Commit method
func (mmCommit *mTxMockCommit) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Tx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Tx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// When sets expectation for the Tx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mTxMockCommit) When(ctx context.Context) *TxMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	expectation := &TxMockCommitExpectation{
		mock:   mmCommit.mock,
		params: &TxMockCommitParams{ctx},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up Tx.Commit return parameters for the expectation previously defined by the When method
func (e *TxMockCommitExpectation) Then(err error) *TxMock {
	e.results = &TxMockCommitResults{err}
	return e.mock
}

// Times sets number of times Tx.Commit should be invoked
func (mmCommit *mTxMockCommit) Times(n uint64) *mTxMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of TxMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	return mmCommit
}

func (mmCommit *mTxMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements pgx.Tx
func (mmCommit *TxMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := TxMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, &mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_want_ptrs := mmCommit.CommitMock.defaultExpectation.paramPtrs

		mm_got := TxMockCommitParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommit.t.Errorf("TxMock.Commit got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("TxMock.Commit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to TxMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished TxMock.Commit invocations
func (mmCommit *TxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TxMock.Commit invocations
func (mmCommit *TxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mTxMockCommit) Calls() []*TxMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*TxMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *TxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Commit with params: %#v", *e.params)
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Commit")
		} else {
			m.t.Errorf("Expected call to TxMock.Commit with params: %#v", *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Error("Expected call to TxMock.Commit")
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Commit but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), afterCommitCounter)
	}
}

type mTxMockConn struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockConnExpectation
	expectations       []*TxMockConnExpectation

	expectedInvocations uint64
}

// TxMockConnExpectation specifies expectation struct of the Tx.Conn
type TxMockConnExpectation struct {
	mock *TxMock

	results *TxMockConnResults
	Counter uint64
}

// TxMockConnResults contains results of the Tx.Conn
type TxMockConnResults struct {
	cp1 *mm_pgx.Conn
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConn *mTxMockConn) Optional() *mTxMockConn {
	mmConn.optional = true
	return mmConn
}

// Expect sets up expected params for Tx.Conn
func (mmConn *mTxMockConn) Expect() *mTxMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the Tx.Conn
func (mmConn *mTxMockConn) Inspect(f func()) *mTxMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for TxMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by Tx.Conn
func (mmConn *mTxMockConn) Return(cp1 *mm_pgx.Conn) *TxMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &TxMockConnResults{cp1}
	return mmConn.mock
}

// Set uses given function f to mock the Tx.Conn method
func (mmConn *mTxMockConn) Set(f func() (cp1 *mm_pgx.Conn)) *TxMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the Tx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the Tx.Conn method")
	}

	mmConn.mock.funcConn = f
	return mmConn.mock
}

// Times sets number of times Tx.Conn should be invoked
func (mmConn *mTxMockConn) Times(n uint64) *mTxMockConn {
	if n == 0 {
		mmConn.mock.t.Fatalf("Times of TxMock.Conn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConn.expectedInvocations, n)
	return mmConn
}

func (mmConn *mTxMockConn) invocationsDone() bool {
	if len(mmConn.expectations) == 0 && mmConn.defaultExpectation == nil && mmConn.mock.funcConn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConn.mock.afterConnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Conn implements pgx.Tx
func (mmConn *TxMock) Conn() (cp1 *mm_pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the TxMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to TxMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished TxMock.Conn invocations
func (mmConn *TxMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of TxMock.Conn invocations
func (mmConn *TxMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockConnDone() bool {
	if m.ConnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnMock.invocationsDone()
}

// MinimockConnInspect logs each unmet expectation
func (m *TxMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Conn")
		}
	}

	afterConnCounter := mm_atomic.LoadUint64(&m.afterConnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && afterConnCounter < 1 {
		m.t.Error("Expected call to TxMock.Conn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && afterConnCounter < 1 {
		m.t.Error("Expected call to TxMock.Conn")
	}

	if !m.ConnMock.invocationsDone() && afterConnCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Conn but found %d calls",
			mm_atomic.LoadUint64(&m.ConnMock.expectedInvocations), afterConnCounter)
	}
}

type mTxMockCopyFrom struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockCopyFromExpectation
	expectations       []*TxMockCopyFromExpectation

	callArgs []*TxMockCopyFromParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockCopyFromExpectation specifies expectation struct of the Tx.CopyFrom
type TxMockCopyFromExpectation struct {
	mock      *TxMock
	params    *TxMockCopyFromParams
	paramPtrs *TxMockCopyFromParamPtrs
	results   *TxMockCopyFromResults
	Counter   uint64
}

// TxMockCopyFromParams contains parameters of the Tx.CopyFrom
type TxMockCopyFromParams struct {
	ctx         context.Context
	tableName   mm_pgx.Identifier
	columnNames []string
	rowSrc      mm_pgx.CopyFromSource
}

// TxMockCopyFromParamPtrs contains pointers to parameters of the Tx.CopyFrom
type TxMockCopyFromParamPtrs struct {
	ctx         *context.Context
	tableName   *mm_pgx.Identifier
	columnNames *[]string
	rowSrc      *mm_pgx.CopyFromSource
}

// TxMockCopyFromResults contains results of the Tx.CopyFrom
type TxMockCopyFromResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCopyFrom *mTxMockCopyFrom) Optional() *mTxMockCopyFrom {
	mmCopyFrom.optional = true
	return mmCopyFrom
}

// Expect sets up expected params for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Expect(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.paramPtrs != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by ExpectParams functions")
	}

	mmCopyFrom.defaultExpectation.params = &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// ExpectCtxParam1 sets up expected param ctx for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectCtxParam1(ctx context.Context) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCopyFrom
}

// ExpectTableNameParam2 sets up expected param tableName for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectTableNameParam2(tableName mm_pgx.Identifier) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.tableName = &tableName

	return mmCopyFrom
}

// ExpectColumnNamesParam3 sets up expected param columnNames for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectColumnNamesParam3(columnNames []string) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.columnNames = &columnNames

	return mmCopyFrom
}

// ExpectRowSrcParam4 sets up expected param rowSrc for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectRowSrcParam4(rowSrc mm_pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.rowSrc = &rowSrc

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Inspect(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)) *mTxMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for TxMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Return(i1 int64, err error) *TxMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &TxMockCopyFromResults{i1, err}
	return mmCopyFrom.mock
}

// Set uses given function f to mock the Tx.CopyFrom method
func (mmCopyFrom *mTxMockCopyFrom) Set(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)) *TxMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the Tx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the Tx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	return mmCopyFrom.mock
}

// When sets expectation for the Tx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mTxMockCopyFrom) When(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *TxMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	expectation := &TxMockCopyFromExpectation{
		mock:   mmCopyFrom.mock,
		params: &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up Tx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *TxMockCopyFromExpectation) Then(i1 int64, err error) *TxMock {
	e.results = &TxMockCopyFromResults{i1, err}
	return e.mock
}

// Times sets number of times Tx.CopyFrom should be invoked
func (mmCopyFrom *mTxMockCopyFrom) Times(n uint64) *mTxMockCopyFrom {
	if n == 0 {
		mmCopyFrom.mock.t.Fatalf("Times of TxMock.CopyFrom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCopyFrom.expectedInvocations, n)
	return mmCopyFrom
}

func (mmCopyFrom *mTxMockCopyFrom) invocationsDone() bool {
	if len(mmCopyFrom.expectations) == 0 && mmCopyFrom.defaultExpectation == nil && mmCopyFrom.mock.funcCopyFrom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCopyFrom.mock.afterCopyFromCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCopyFrom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CopyFrom implements pgx.Tx
func (mmCopyFrom *TxMock) CopyFrom(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, &mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_want_ptrs := mmCopyFrom.CopyFromMock.defaultExpectation.paramPtrs

		mm_got := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter tableName, want: %#v, got: %#v%s\n", *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.columnNames != nil && !minimock.Equal(*mm_want_ptrs.columnNames, mm_got.columnNames) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter columnNames, want: %#v, got: %#v%s\n", *mm_want_ptrs.columnNames, mm_got.columnNames, minimock.Diff(*mm_want_ptrs.columnNames, mm_got.columnNames))
			}

			if mm_want_ptrs.rowSrc != nil && !minimock.Equal(*mm_want_ptrs.rowSrc, mm_got.rowSrc) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter rowSrc, want: %#v, got: %#v%s\n", *mm_want_ptrs.rowSrc, mm_got.rowSrc, minimock.Diff(*mm_want_ptrs.rowSrc, mm_got.rowSrc))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the TxMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to TxMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to TxMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mTxMockCopyFrom) Calls() []*TxMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*TxMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCopyFromDone() bool {
	if m.CopyFromMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CopyFromMock.invocationsDone()
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *TxMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.CopyFrom with params: %#v", *e.params)
		}
	}

	afterCopyFromCounter := mm_atomic.LoadUint64(&m.afterCopyFromCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && afterCopyFromCounter < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.CopyFrom")
		} else {
			m.t.Errorf("Expected call to TxMock.CopyFrom with params: %#v", *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && afterCopyFromCounter < 1 {
		m.t.Error("Expected call to TxMock.CopyFrom")
	}

	if !m.CopyFromMock.invocationsDone() && afterCopyFromCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.CopyFrom but found %d calls",
			mm_atomic.LoadUint64(&m.CopyFromMock.expectedInvocations), afterCopyFromCounter)
	}
}

type mTxMockExec struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockExecExpectation
	expectations       []*TxMockExecExpectation

	callArgs []*TxMockExecParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockExecExpectation specifies expectation struct of the Tx.Exec
type TxMockExecExpectation struct {
	mock      *TxMock
	params    *TxMockExecParams
	paramPtrs *TxMockExecParamPtrs
	results   *TxMockExecResults
	Counter   uint64
}

// TxMockExecParams contains parameters of the Tx.Exec
type TxMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []any
}

// TxMockExecParamPtrs contains pointers to parameters of the Tx.Exec
type TxMockExecParamPtrs struct {
	ctx       *context.Context
	sql       *string
	arguments *[]any
}

// TxMockExecResults contains results of the Tx.Exec
type TxMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mTxMockExec) Optional() *mTxMockExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for Tx.Exec
func (mmExec *mTxMockExec) Expect(ctx context.Context, sql string, arguments ...any) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &TxMockExecParams{ctx, sql, arguments}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Exec
func (mmExec *mTxMockExec) ExpectCtxParam1(ctx context.Context) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExec
}

// ExpectSqlParam2 sets up expected param sql for Tx.Exec
func (mmExec *mTxMockExec) ExpectSqlParam2(sql string) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.sql = &sql

	return mmExec
}

// ExpectArgumentsParam3 sets up expected param arguments for Tx.Exec
func (mmExec *mTxMockExec) ExpectArgumentsParam3(arguments ...any) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.arguments = &arguments

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Tx.Exec
func (mmExec *mTxMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...any)) *mTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for TxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Tx.Exec
func (mmExec *mTxMockExec) Return(commandTag pgconn.CommandTag, err error) *TxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &TxMockExecResults{commandTag, err}
	return mmExec.mock
}

// Set uses given function f to mock the Tx.Exec method
func (mmExec *mTxMockExec) Set(f func(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)) *TxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Tx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Tx.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the Tx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mTxMockExec) When(ctx context.Context, sql string, arguments ...any) *TxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	expectation := &TxMockExecExpectation{
		mock:   mmExec.mock,
		params: &TxMockExecParams{ctx, sql, arguments},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Tx.Exec return parameters for the expectation previously defined by the When method
func (e *TxMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *TxMock {
	e.results = &TxMockExecResults{commandTag, err}
	return e.mock
}

// Times sets number of times Tx.Exec should be invoked
func (mmExec *mTxMockExec) Times(n uint64) *mTxMockExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of TxMock.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	return mmExec
}

func (mmExec *mTxMockExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements pgx.Tx
func (mmExec *TxMock) Exec(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := TxMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := TxMockExecParams{ctx, sql, arguments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.arguments != nil && !minimock.Equal(*mm_want_ptrs.arguments, mm_got.arguments) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter arguments, want: %#v, got: %#v%s\n", *mm_want_ptrs.arguments, mm_got.arguments, minimock.Diff(*mm_want_ptrs.arguments, mm_got.arguments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("TxMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the TxMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to TxMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished TxMock.Exec invocations
func (mmExec *TxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of TxMock.Exec invocations
func (mmExec *TxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mTxMockExec) Calls() []*TxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*TxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *TxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Exec with params: %#v", *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Exec")
		} else {
			m.t.Errorf("Expected call to TxMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Error("Expected call to TxMock.Exec")
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Exec but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), afterExecCounter)
	}
}

type mTxMockLargeObjects struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockLargeObjectsExpectation
	expectations       []*TxMockLargeObjectsExpectation

	expectedInvocations uint64
}

// TxMockLargeObjectsExpectation specifies expectation struct of the Tx.LargeObjects
type TxMockLargeObjectsExpectation struct {
	mock *TxMock

	results *TxMockLargeObjectsResults
	Counter uint64
}

// TxMockLargeObjectsResults contains results of the Tx.LargeObjects
type TxMockLargeObjectsResults struct {
	l1 mm_pgx.LargeObjects
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLargeObjects *mTxMockLargeObjects) Optional() *mTxMockLargeObjects {
	mmLargeObjects.optional = true
	return mmLargeObjects
}

// Expect sets up expected params for Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Expect() *mTxMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Inspect(f func()) *mTxMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for TxMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Return(l1 mm_pgx.LargeObjects) *TxMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &TxMockLargeObjectsResults{l1}
	return mmLargeObjects.mock
}

// Set uses given function f to mock the Tx.LargeObjects method
func (mmLargeObjects *mTxMockLargeObjects) Set(f func() (l1 mm_pgx.LargeObjects)) *TxMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the Tx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the Tx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	return mmLargeObjects.mock
}

// Times sets number of times Tx.LargeObjects should be invoked
func (mmLargeObjects *mTxMockLargeObjects) Times(n uint64) *mTxMockLargeObjects {
	if n == 0 {
		mmLargeObjects.mock.t.Fatalf("Times of TxMock.LargeObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLargeObjects.expectedInvocations, n)
	return mmLargeObjects
}

func (mmLargeObjects *mTxMockLargeObjects) invocationsDone() bool {
	if len(mmLargeObjects.expectations) == 0 && mmLargeObjects.defaultExpectation == nil && mmLargeObjects.mock.funcLargeObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLargeObjects.mock.afterLargeObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLargeObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LargeObjects implements pgx.Tx
func (mmLargeObjects *TxMock) LargeObjects() (l1 mm_pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the TxMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to TxMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockLargeObjectsDone() bool {
	if m.LargeObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LargeObjectsMock.invocationsDone()
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *TxMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.LargeObjects")
		}
	}

	afterLargeObjectsCounter := mm_atomic.LoadUint64(&m.afterLargeObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && afterLargeObjectsCounter < 1 {
		m.t.Error("Expected call to TxMock.LargeObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && afterLargeObjectsCounter < 1 {
		m.t.Error("Expected call to TxMock.LargeObjects")
	}

	if !m.LargeObjectsMock.invocationsDone() && afterLargeObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.LargeObjects but found %d calls",
			mm_atomic.LoadUint64(&m.LargeObjectsMock.expectedInvocations), afterLargeObjectsCounter)
	}
}

type mTxMockPrepare struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockPrepareExpectation
	expectations       []*TxMockPrepareExpectation

	callArgs []*TxMockPrepareParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockPrepareExpectation specifies expectation struct of the Tx.Prepare
type TxMockPrepareExpectation struct {
	mock      *TxMock
	params    *TxMockPrepareParams
	paramPtrs *TxMockPrepareParamPtrs
	results   *TxMockPrepareResults
	Counter   uint64
}

// TxMockPrepareParams contains parameters of the Tx.Prepare
type TxMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// TxMockPrepareParamPtrs contains pointers to parameters of the Tx.Prepare
type TxMockPrepareParamPtrs struct {
	ctx  *context.Context
	name *string
	sql  *string
}

// TxMockPrepareResults contains results of the Tx.Prepare
type TxMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrepare *mTxMockPrepare) Optional() *mTxMockPrepare {
	mmPrepare.optional = true
	return mmPrepare
}

// Expect sets up expected params for Tx.Prepare
func (mmPrepare *mTxMockPrepare) Expect(ctx context.Context, name string, sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.paramPtrs != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by ExpectParams functions")
	}

	mmPrepare.defaultExpectation.params = &TxMockPrepareParams{ctx, name, sql}
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectCtxParam1(ctx context.Context) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPrepare
}

// ExpectNameParam2 sets up expected param name for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectNameParam2(name string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.name = &name

	return mmPrepare
}

// ExpectSqlParam3 sets up expected param sql for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectSqlParam3(sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.sql = &sql

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the Tx.Prepare
func (mmPrepare *mTxMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for TxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by Tx.Prepare
func (mmPrepare *mTxMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *TxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &TxMockPrepareResults{sp1, err}
	return mmPrepare.mock
}

// Set uses given function f to mock the Tx.Prepare method
func (mmPrepare *mTxMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *TxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the Tx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the Tx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	return mmPrepare.mock
}

// When sets expectation for the Tx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mTxMockPrepare) When(ctx context.Context, name string, sql string) *TxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	expectation := &TxMockPrepareExpectation{
		mock:   mmPrepare.mock,
		params: &TxMockPrepareParams{ctx, name, sql},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up Tx.Prepare return parameters for the expectation previously defined by the When method
func (e *TxMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *TxMock {
	e.results = &TxMockPrepareResults{sp1, err}
	return e.mock
}

// Times sets number of times Tx.Prepare should be invoked
func (mmPrepare *mTxMockPrepare) Times(n uint64) *mTxMockPrepare {
	if n == 0 {
		mmPrepare.mock.t.Fatalf("Times of TxMock.Prepare mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrepare.expectedInvocations, n)
	return mmPrepare
}

func (mmPrepare *mTxMockPrepare) invocationsDone() bool {
	if len(mmPrepare.expectations) == 0 && mmPrepare.defaultExpectation == nil && mmPrepare.mock.funcPrepare == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrepare.mock.afterPrepareCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrepare.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Prepare implements pgx.Tx
func (mmPrepare *TxMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := TxMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, &mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_want_ptrs := mmPrepare.PrepareMock.defaultExpectation.paramPtrs

		mm_got := TxMockPrepareParams{ctx, name, sql}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the TxMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to TxMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mTxMockPrepare) Calls() []*TxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*TxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockPrepareDone() bool {
	if m.PrepareMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrepareMock.invocationsDone()
}

// MinimockPrepareInspect logs each unmet expectation
func (m *TxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Prepare with params: %#v", *e.params)
		}
	}

	afterPrepareCounter := mm_atomic.LoadUint64(&m.afterPrepareCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && afterPrepareCounter < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Prepare")
		} else {
			m.t.Errorf("Expected call to TxMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && afterPrepareCounter < 1 {
		m.t.Error("Expected call to TxMock.Prepare")
	}

	if !m.PrepareMock.invocationsDone() && afterPrepareCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Prepare but found %d calls",
			mm_atomic.LoadUint64(&m.PrepareMock.expectedInvocations), afterPrepareCounter)
	}
}

type mTxMockQuery struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryExpectation
	expectations       []*TxMockQueryExpectation

	callArgs []*TxMockQueryParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockQueryExpectation specifies expectation struct of the Tx.Query
type TxMockQueryExpectation struct {
	mock      *TxMock
	params    *TxMockQueryParams
	paramPtrs *TxMockQueryParamPtrs
	results   *TxMockQueryResults
	Counter   uint64
}

// TxMockQueryParams contains parameters of the Tx.Query
type TxMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []any
}

// TxMockQueryParamPtrs contains pointers to parameters of the Tx.Query
type TxMockQueryParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]any
}

// TxMockQueryResults contains results of the Tx.Query
type TxMockQueryResults struct {
	r1  mm_pgx.Rows
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuery *mTxMockQuery) Optional() *mTxMockQuery {
	mmQuery.optional = true
	return mmQuery
}

// Expect sets up expected params for Tx.Query
func (mmQuery *mTxMockQuery) Expect(ctx context.Context, sql string, args ...any) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.paramPtrs != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by ExpectParams functions")
	}

	mmQuery.defaultExpectation.params = &TxMockQueryParams{ctx, sql, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Query
func (mmQuery *mTxMockQuery) ExpectCtxParam1(ctx context.Context) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.ctx = &ctx

	return mmQuery
}

// ExpectSqlParam2 sets up expected param sql for Tx.Query
func (mmQuery *mTxMockQuery) ExpectSqlParam2(sql string) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.sql = &sql

	return mmQuery
}

// ExpectArgsParam3 sets up expected param args for Tx.Query
func (mmQuery *mTxMockQuery) ExpectArgsParam3(args ...any) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.args = &args

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the Tx.Query
func (mmQuery *mTxMockQuery) Inspect(f func(ctx context.Context, sql string, args ...any)) *mTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for TxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by Tx.Query
func (mmQuery *mTxMockQuery) Return(r1 mm_pgx.Rows, err error) *TxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &TxMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the Tx.Query method
func (mmQuery *mTxMockQuery) Set(f func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Rows, err error)) *TxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the Tx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the Tx.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the Tx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mTxMockQuery) When(ctx context.Context, sql string, args ...any) *TxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	expectation := &TxMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &TxMockQueryParams{ctx, sql, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up Tx.Query return parameters for the expectation previously defined by the When method
func (e *TxMockQueryExpectation) Then(r1 mm_pgx.Rows, err error) *TxMock {
	e.results = &TxMockQueryResults{r1, err}
	return e.mock
}

// Times sets number of times Tx.Query should be invoked
func (mmQuery *mTxMockQuery) Times(n uint64) *mTxMockQuery {
	if n == 0 {
		mmQuery.mock.t.Fatalf("Times of TxMock.Query mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuery.expectedInvocations, n)
	return mmQuery
}

func (mmQuery *mTxMockQuery) invocationsDone() bool {
	if len(mmQuery.expectations) == 0 && mmQuery.defaultExpectation == nil && mmQuery.mock.funcQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuery.mock.afterQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Query implements pgx.Tx
func (mmQuery *TxMock) Query(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := TxMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_want_ptrs := mmQuery.QueryMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("TxMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the TxMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to TxMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished TxMock.Query invocations
func (mmQuery *TxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of TxMock.Query invocations
func (mmQuery *TxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mTxMockQuery) Calls() []*TxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*TxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryDone() bool {
	if m.QueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryMock.invocationsDone()
}

// MinimockQueryInspect logs each unmet expectation
func (m *TxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Query with params: %#v", *e.params)
		}
	}

	afterQueryCounter := mm_atomic.LoadUint64(&m.afterQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && afterQueryCounter < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Query")
		} else {
			m.t.Errorf("Expected call to TxMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && afterQueryCounter < 1 {
		m.t.Error("Expected call to TxMock.Query")
	}

	if !m.QueryMock.invocationsDone() && afterQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Query but found %d calls",
			mm_atomic.LoadUint64(&m.QueryMock.expectedInvocations), afterQueryCounter)
	}
}

type mTxMockQueryRow struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryRowExpectation
	expectations       []*TxMockQueryRowExpectation

	callArgs []*TxMockQueryRowParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockQueryRowExpectation specifies expectation struct of the Tx.QueryRow
type TxMockQueryRowExpectation struct {
	mock      *TxMock
	params    *TxMockQueryRowParams
	paramPtrs *TxMockQueryRowParamPtrs
	results   *TxMockQueryRowResults
	Counter   uint64
}

// TxMockQueryRowParams contains parameters of the Tx.QueryRow
type TxMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []any
}

// TxMockQueryRowParamPtrs contains pointers to parameters of the Tx.QueryRow
type TxMockQueryRowParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]any
}

// TxMockQueryRowResults contains results of the Tx.QueryRow
type TxMockQueryRowResults struct {
	r1 mm_pgx.Row
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRow *mTxMockQueryRow) Optional() *mTxMockQueryRow {
	mmQueryRow.optional = true
	return mmQueryRow
}

// Expect sets up expected params for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Expect(ctx context.Context, sql string, args ...any) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.paramPtrs != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by ExpectParams functions")
	}

	mmQueryRow.defaultExpectation.params = &TxMockQueryRowParams{ctx, sql, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// ExpectCtxParam1 sets up expected param ctx for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectCtxParam1(ctx context.Context) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.ctx = &ctx

	return mmQueryRow
}

// ExpectSqlParam2 sets up expected param sql for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectSqlParam2(sql string) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.sql = &sql

	return mmQueryRow
}

// ExpectArgsParam3 sets up expected param args for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectArgsParam3(args ...any) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.args = &args

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...any)) *mTxMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for TxMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Return(r1 mm_pgx.Row) *TxMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &TxMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the Tx.QueryRow method
func (mmQueryRow *mTxMockQueryRow) Set(f func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Row)) *TxMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the Tx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the Tx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the Tx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mTxMockQueryRow) When(ctx context.Context, sql string, args ...any) *TxMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	expectation := &TxMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &TxMockQueryRowParams{ctx, sql, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryRow return parameters for the expectation previously defined by the When method
func (e *TxMockQueryRowExpectation) Then(r1 mm_pgx.Row) *TxMock {
	e.results = &TxMockQueryRowResults{r1}
	return e.mock
}

// Times sets number of times Tx.QueryRow should be invoked
func (mmQueryRow *mTxMockQueryRow) Times(n uint64) *mTxMockQueryRow {
	if n == 0 {
		mmQueryRow.mock.t.Fatalf("Times of TxMock.QueryRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRow.expectedInvocations, n)
	return mmQueryRow
}

func (mmQueryRow *mTxMockQueryRow) invocationsDone() bool {
	if len(mmQueryRow.expectations) == 0 && mmQueryRow.defaultExpectation == nil && mmQueryRow.mock.funcQueryRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRow.mock.afterQueryRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRow implements pgx.Tx
func (mmQueryRow *TxMock) QueryRow(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := TxMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRow.QueryRowMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryRowParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter sql, want: %#v, got: %#v%s\n", *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter args, want: %#v, got: %#v%s\n", *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the TxMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to TxMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to TxMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mTxMockQueryRow) Calls() []*TxMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*TxMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryRowDone() bool {
	if m.QueryRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowMock.invocationsDone()
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *TxMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.QueryRow with params: %#v", *e.params)
		}
	}

	afterQueryRowCounter := mm_atomic.LoadUint64(&m.afterQueryRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && afterQueryRowCounter < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to TxMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && afterQueryRowCounter < 1 {
		m.t.Error("Expected call to TxMock.QueryRow")
	}

	if !m.QueryRowMock.invocationsDone() && afterQueryRowCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.QueryRow but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowMock.expectedInvocations), afterQueryRowCounter)
	}
}

type mTxMockRollback struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockRollbackExpectation
	expectations       []*TxMockRollbackExpectation

	callArgs []*TxMockRollbackParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockRollbackExpectation specifies expectation struct of the Tx.Rollback
type TxMockRollbackExpectation struct {
	mock      *TxMock
	params    *TxMockRollbackParams
	paramPtrs *TxMockRollbackParamPtrs
	results   *TxMockRollbackResults
	Counter   uint64
}

// TxMockRollbackParams contains parameters of the Tx.Rollback
type TxMockRollbackParams struct {
	ctx context.Context
}

// TxMockRollbackParamPtrs contains pointers to parameters of the Tx.Rollback
type TxMockRollbackParamPtrs struct {
	ctx *context.Context
}

// TxMockRollbackResults contains results of the Tx.Rollback
type TxMockRollbackResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollback *mTxMockRollback) Optional() *mTxMockRollback {
	mmRollback.optional = true
	return mmRollback
}

// Expect sets up expected params for Tx.Rollback
func (mmRollback *mTxMockRollback) Expect(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.paramPtrs != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by ExpectParams functions")
	}

	mmRollback.defaultExpectation.params = &TxMockRollbackParams{ctx}
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Rollback
func (mmRollback *mTxMockRollback) ExpectCtxParam1(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.params != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Expect")
	}

	if mmRollback.defaultExpectation.paramPtrs == nil {
		mmRollback.defaultExpectation.paramPtrs = &TxMockRollbackParamPtrs{}
	}
	mmRollback.defaultExpectation.paramPtrs.ctx = &ctx

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Tx.Rollback
func (mmRollback *mTxMockRollback) Inspect(f func(ctx context.Context)) *mTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Tx.Rollback
func (mmRollback *mTxMockRollback) Return(err error) *TxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &TxMockRollbackResults{err}
	return mmRollback.mock
}

// Set uses given function f to mock the Tx.Rollback method
func (mmRollback *mTxMockRollback) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Tx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Tx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// When sets expectation for the Tx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mTxMockRollback) When(ctx context.Context) *TxMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	expectation := &TxMockRollbackExpectation{
		mock:   mmRollback.mock,
		params: &TxMockRollbackParams{ctx},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up Tx.Rollback return parameters for the expectation previously defined by the When method
func (e *TxMockRollbackExpectation) Then(err error) *TxMock {
	e.results = &TxMockRollbackResults{err}
	return e.mock
}

// Times sets number of times Tx.Rollback should be invoked
func (mmRollback *mTxMockRollback) Times(n uint64) *mTxMockRollback {
	if n == 0 {
		mmRollback.mock.t.Fatalf("Times of TxMock.Rollback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollback.expectedInvocations, n)
	return mmRollback
}

func (mmRollback *mTxMockRollback) invocationsDone() bool {
	if len(mmRollback.expectations) == 0 && mmRollback.defaultExpectation == nil && mmRollback.mock.funcRollback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollback.mock.afterRollbackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Rollback implements pgx.Tx
func (mmRollback *TxMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := TxMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, &mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_want_ptrs := mmRollback.RollbackMock.defaultExpectation.paramPtrs

		mm_got := TxMockRollbackParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollback.t.Errorf("TxMock.Rollback got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("TxMock.Rollback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the TxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to TxMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mTxMockRollback) Calls() []*TxMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*TxMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockRollbackDone() bool {
	if m.RollbackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackMock.invocationsDone()
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Rollback with params: %#v", *e.params)
		}
	}

	afterRollbackCounter := mm_atomic.LoadUint64(&m.afterRollbackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && afterRollbackCounter < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.Rollback")
		} else {
			m.t.Errorf("Expected call to TxMock.Rollback with params: %#v", *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && afterRollbackCounter < 1 {
		m.t.Error("Expected call to TxMock.Rollback")
	}

	if !m.RollbackMock.invocationsDone() && afterRollbackCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Rollback but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackMock.expectedInvocations), afterRollbackCounter)
	}
}

type mTxMockSendBatch struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockSendBatchExpectation
	expectations       []*TxMockSendBatchExpectation

	callArgs []*TxMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// TxMockSendBatchExpectation specifies expectation struct of the Tx.SendBatch
type TxMockSendBatchExpectation struct {
	mock      *TxMock
	params    *TxMockSendBatchParams
	paramPtrs *TxMockSendBatchParamPtrs
	results   *TxMockSendBatchResults
	Counter   uint64
}

// TxMockSendBatchParams contains parameters of the Tx.SendBatch
type TxMockSendBatchParams struct {
	ctx context.Context
	b   *mm_pgx.Batch
}

// TxMockSendBatchParamPtrs contains pointers to parameters of the Tx.SendBatch
type TxMockSendBatchParamPtrs struct {
	ctx *context.Context
	b   **mm_pgx.Batch
}

// TxMockSendBatchResults contains results of the Tx.SendBatch
type TxMockSendBatchResults struct {
	b1 mm_pgx.BatchResults
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mTxMockSendBatch) Optional() *mTxMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Expect(ctx context.Context, b *mm_pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &TxMockSendBatchParams{ctx, b}
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectCtxParam1 sets up expected param ctx for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) ExpectCtxParam1(ctx context.Context) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSendBatch
}

// ExpectBParam2 sets up expected param b for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) ExpectBParam2(b *mm_pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.b = &b

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Inspect(f func(ctx context.Context, b *mm_pgx.Batch)) *mTxMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for TxMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Return(b1 mm_pgx.BatchResults) *TxMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &TxMockSendBatchResults{b1}
	return mmSendBatch.mock
}

// Set uses given function f to mock the Tx.SendBatch method
func (mmSendBatch *mTxMockSendBatch) Set(f func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)) *TxMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Tx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Tx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	return mmSendBatch.mock
}

// When sets expectation for the Tx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mTxMockSendBatch) When(ctx context.Context, b *mm_pgx.Batch) *TxMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	expectation := &TxMockSendBatchExpectation{
		mock:   mmSendBatch.mock,
		params: &TxMockSendBatchParams{ctx, b},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Tx.SendBatch return parameters for the expectation previously defined by the When method
func (e *TxMockSendBatchExpectation) Then(b1 mm_pgx.BatchResults) *TxMock {
	e.results = &TxMockSendBatchResults{b1}
	return e.mock
}

// Times sets number of times Tx.SendBatch should be invoked
func (mmSendBatch *mTxMockSendBatch) Times(n uint64) *mTxMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of TxMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	return mmSendBatch
}

func (mmSendBatch *mTxMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements pgx.Tx
func (mmSendBatch *TxMock) SendBatch(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := TxMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := TxMockSendBatchParams{ctx, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameter b, want: %#v, got: %#v%s\n", *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the TxMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to TxMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to TxMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mTxMockSendBatch) Calls() []*TxMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*TxMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *TxMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.SendBatch with params: %#v", *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TxMock.SendBatch")
		} else {
			m.t.Errorf("Expected call to TxMock.SendBatch with params: %#v", *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Error("Expected call to TxMock.SendBatch")
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.SendBatch but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockCommitInspect()

			m.MinimockConnInspect()

			m.MinimockCopyFromInspect()

			m.MinimockExecInspect()

			m.MinimockLargeObjectsInspect()

			m.MinimockPrepareInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryRowInspect()

			m.MinimockRollbackInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
